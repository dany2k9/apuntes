<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
	<title></title>  
  <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">  
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script> 
    <!-- 14/02 -->
    <link rel="stylesheet" href="codemirror/lib/codemirror.css">
    <script src="codemirror/lib/codemirror.js"></script>
    <script src="codemirror/addon/edit/matchbrackets.js"></script>
    <script src="codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <script src="codemirror/mode/xml/xml.js"></script>
    <script src="codemirror/mode/javascript/javascript.js"></script>
    <script src="codemirror/mode/css/css.js"></script>
    <script src="codemirror/mode/clike/clike.js"></script>
    <script src="codemirror/mode/php/php.js"></script>
    <style type="text/css">.CodeMirror {border: 1px solid black; width: 60%;height:auto; backgro}</style>
    <link rel="stylesheet" href="codemirror/doc/docs.css">
    <!-- 14/02 -->
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
</head>
<body>
<h1>Programación Orientada a Objetos en PHP5 </h1>
Principio 1: <b>RTFM - "Lee el Maldito Manual"</b>  <br>
Principio 2: <b>DRY - "No Te Repitas"</b> <br>
Principio 3: <b>KISS - "Mantenlo Simple, Estúpido!"</b><br> 
Principio 4: Estándar de Codificación PHP / Zend<br><br>

HTTP://FRAMEWORK.ZEND.COM/WIKI/DISPLAY/ZFDEV/PHP+CODING+STANDARD+(DRAFT) <br><br>

¿Qué es lo que intenta hacer entonces la Programación Orientada a los Objetos 
(POO)?<br>
<b>“simplificar las abstracciones”</b><br><br>

Lo más importante, es detectar los objetos dentro de un contexto determinado. <br><br>

<b>“todo sistema tiene un contexto, un sistema no puede aplicarse en absolutamente 
todos los contextos”</b><br><br>

<p>
El contexto, los objetos, sus atributos, sus acciones, cuáles pueden ser 
conocidos por otros objetos y cuales son (o deben ser) naturalmente internos del 
propio objeto, para finalmente hacerlos interactuar como en una obra de teatro o 
en un cuento, con varios posibles principios y finales según la historia que 
necesitemos contar. 
</p>
http://es.wikipedia.org/wiki/POO <br><br>

1. La POO es un paradigma que tiene sus orígenes desde antes de 1990 <br>
2. <b>“Los objetos son entidades que combinan estado, comportamiento e 1identidad”</b> <br>
3. Fundamental, los beneficios que obtenemos usando este paradigma: <br> 
- <b>“La programación orientada a objetos expresa un programa como un conjunto de 
estos objetos, que colaboran entre ellos para realizar tareas. Esto permite 
hacer los programas y módulos más fáciles de escribir, mantener y reutilizar.”</b><br> 
4. La razón de por qué no es necesario que todos los objetos que creemos tengan 
un id como si fuera una clave primaria de una tabla (con el fin de ubicar un 
objeto en particular): <br>
-<b>“De esta forma, un objeto contiene toda la información que permite definirlo e identificarlo frente a otros objetos pertenecientes a otras clases e incluso 
frente a objetos de una misma clase, al poder tener valores bien diferenciados 
en sus atributos.”</b><br> 
5. Diferencias con respecto a la Programación Estructurada versus Programación 
Orientada a Objetos: la primera se pensó como funcionalidad por un lado y datos 
por otro, es decir, llamar a una función y pasarle constantemente datos para 
que los procese, mientras que la POO está pensada para tener todo integrado en 
el mismo objeto. <br>
- <b>“En la programación estructurada sólo se escriben funciones que procesan 
datos. <br>
Los programadores que emplean éste nuevo paradigma, en cambio, primero definen 
objetos para luego enviarles mensajes solicitándoles que realicen sus métodos 
por sí mismos.”</b><br> 
6. Muy importante es tener SIEMPRE en claro los conceptos FUNDAMENTALES, si no 
los tienes claros cuando programas OO, algo está mal, seguro errarás el camino 
que define el paradigma: Clase, Herencia, Objeto, Método, Evento, Mensaje, 
Atributo, Estado Interno, Componentes de un objeto y Representación de un 
objeto. <br>
7. Características de la POO: igual que el punto anterior, es fundamental tener 
claros estos conceptos cada vez que desarrollamos, con principal énfasis en el 
Principio de Ocultación (que es muy común confundir con Encapsulamiento), lo que 
explica por qué no deberían existir los atributos públicos ni abusar de los 
setter/getter <br><br>

http://ar2.php.net/manual/es/langref.php<br>
http://ar2.php.net/oop<br><br>

1) <b>“Los Objetos tienen Atributos, Comportamientos y Estados”</b><br> 
3) <b>“La clase, un molde para construir objetos”</b><br> 
4) <b>“Los atributos y comportamientos pueden ser públicos o privados” </b><br><br>

<b>“acceso público”</b><br>
<b>“acceso privado”</b><br><br>

http://www.programacionextrema.org/articulos/designdead.es.html<br><br><br>

Las clases se construyen en la etapa de diseño donde definimos qué es lo que 
queremos crear.<br><br>

<h3>Lenguaje Unificado de Modelado (UML)</h3>

<b>diagramas de Casos de Uso diagramas de clases y diagramas de paquetes. </b><br><br>

Los diagramas UML permiten unificar y simplificar la comunicación en un 
proyecto, como así también apoyar el razonamiento en la etapa de diseño de una 
solución.<br><br> 
 
los diagramas MER/DER<br><br>

Primer Regla: de nomenclatura, los nombres de las clases son siempre en singular 
y la primer letra de cada palabra en mayúsculas (CamelCase)<br>
-Tablas en base de datos:  personas, animales,usuarios, usuarios_administradores<br> 
- Clases en POO: Persona, Animal, Usuario, UsuarioAdministrador<br> 

<b>“Una persona tiene nombre, apellido y fecha de nacimiento, cuando se le pregunta 
qué edad tiene, responde con su edad que calcula en base a la fecha de 
nacimiento” </b><br>
<img src="uml01.jpg" alt=""><br>
La Sección #1 es para definir el nombre de la clase<br>
La Sección #2 es para definir los atributos de nuestra clase<br> 
La Sección #3 es para definir los métodos de nuestra clase<br><br>

Persona.php<br> 
#1<br>

<textarea id="code" name="code">
<?php  
class Persona  
{ 
  
}  
</textarea>
<script src="https://gist.github.com/4377161.js"></script>  
#2<br>
<script src="https://gist.github.com/4377202.js"></script>

<script src="https://gist.github.com/4377207.js"></script>

#3<br>
<script src="https://gist.github.com/4377224.js"></script>
<br>
la palabra reservada __construct() 
<br>
<script src="https://gist.github.com/4377240.js"></script>


<img src="uml02.jpg" alt=""><br>

<b>“Una clase, una única responsabilidad”</b><br>

Las clases nunca imprimen información, siempre retornan.<br><br>

<b>"getter / setter"</b><br><br>

<b>"accesores / modificadores"</b><br><br>

En PHP4 todos los atributos de un objeto son siempre atributos públicos<br>

<script src="https://gist.github.com/4377252.js"></script>
<br>
PHP5<br>

<script src="https://gist.github.com/4377262.js"></script>

<b>public, private y protected</b><br><br>

<script src="https://gist.github.com/4377310.js"></script>
<p>
los atributos de los objetos deben ser siempre "privados" (concepto 
"encapsulación": no son accesibles desde fuera del objeto, solo el objeto tiene 
la potestad de usarlos directamente) 
</p>
- un método "setter" para "cargar un valor" (asignar un valor a una variable) <br> 
- un método "getter" para "retornar el valor" (solo devolver la información)<br>

Requerimiento 1 <br>
La edad se puede acceder y modificar en todo momento, por consiguiente se deben 
agregar los dos métodos, un "get" y un "set" para ese atributo: <br>

<script src="https://gist.github.com/4377316.js"></script>
<p>
los métodos y atributos privados deben iniciar con “_” y todas las llaves de 
métodos y clases inician a la izquierda (ninguna otra más, como un if, for, etc). 
</p>
Requerimiento 2 <br>
Poder saber el nombre del usuario pero no modificarlo, para eso hay que agregar 
solo un método get para ese atributo:<br> 

<script src="https://gist.github.com/4377320.js"></script>

Requerimiento  3  <br>
No nos interesa que se sepa el nombre real del usuario <br>
 
Lo dejamos como está y queda inaccesible desde fuera del objeto. <br>

Requerimiento  4  <br>
Queremos que pueda colocar una nueva clave si el usuario se la olvida, pero no 
saber la que existe actualmente<br> 

Para eso, hacemos lo contrario que con el atributo nombre, agregamos un método 
"set" pero no el "get": <br>

<script src="https://gist.github.com/4377325.js"></script>

<b>"Evitar que el objeto muestre detalles de su implementación" </b><br><br>

<script src="https://gist.github.com/4377329.js"></script>

1. Por defecto, atributos privados <br>
2. Usa métodos comunes y no getter/setter<br> 
3. Si no queda otra opción, usa solo getter<br> 
4. Si no queda otra opción, usa setter <br>
5. Trata de evitar getter y setter a la vez (efecto "atributo público")<br><br> 

<b>"estado del objeto"</b><br><br>

<b>"los métodos definen el comportamiento del objeto"</b><br><br>

http://www.agile-spain.com/agilev2/blog/traduccionmartinfowler<br><br>

La Relación de Dependencia “es una relación de uso entre dos entidades” (una usa 
a la otra)<br>

La relación de dependencia es cuando una clase depende de la funcionalidad que 
ofrece otra clase. <br>

La representación en UML es una “flecha punteada” o “discontinua” que va desde 
la clase “cliente” del servicio/funcionalidad hasta la clase que ofrece el 
“servicio/funcionalidad”. <br>

<img src="uml03.jpg" alt=""><br>

- La clase A depende de la clase B <br>
- La clase A usa la clase B <br>
- La clase A conoce la existencia de la clase B, pero la clase B no conoce la 
existencia de la clase A (es lo que significa el sentido de la flecha) <br>
- Todo cambio que se haga en la clase B, por la relación que hay con la clase A, 
podrá afectar a la clase A. <br><br>

<b>“relación de uso”</b><br><br>

Solo existen dos situaciones posibles <br>
1. En un método de la clase A instancio un objeto de tipo B y posteriormente lo 
uso.<br> 
2. En un método de la clase A recibo por parámetro un objeto de tipo B y 
posteriormente lo uso. <br>

Caso 1 – instancio un objeto B dentro de un método de A <br>

<script src="https://gist.github.com/4377445.js"></script>
Caso 2 – recibo por parámetro de un método de A un objeto B  <br>

<script src="https://gist.github.com/4377450.js"></script>

<b>Type Hinting (“indicando el tipo”)</b><br><br>

<h3>La Relación de Asociación</h3> 
Definición: <b>“es una relación estructural entre entidades” (una entidad se 
construye a partir de otras entidades)</b><br> 

La relación de asociación es cuando una clase tiene en su estructura a otra 
clase, o se puede decir también que se construye una clase a partir de otros 
elementos u objetos<br>

un objeto Auto y como atributos del mismo tendríamos los objetos Motor, Tanque y 
Antena.<br><br>  

<b>“Principio de Ocultación”</b><br><br>

La representación en UML es una “flecha continua” que va apuntando desde la 
clase “compuesto” hasta la o las clases “componentes”.

<img src="uml04.jpg" alt=""><br>
- La clase A depende de la clase B<br> 
- La clase A está asociada a la clase B<br> 
- La clase A conoce la existencia de la clase B, pero la clase B no conoce la 
existencia de la clase A (sentido de la flecha)<br> 
- Todo cambio que se haga en la clase B, por la relación que hay con la clase A, 
podrá afectar a la clase A. <br>

Creando una clase A que tiene como atributo un objeto de tipo clase B. <br>


<script src="https://gist.github.com/4377455.js"></script>

PHP no soporta la creación de instancias en la definición de atributos<br>

<script src="https://gist.github.com/4377459.js"></script>

Variaciones de Asociación:<br> 
Relación de Agregación y Relación de Composición <br>

Relación de Agregación <br>
Es una relación de asociación pero en vez de ser “1 a 1” es de “1 a muchos”, la 
clase A agrega muchos elementos de tipo clase B<br> 

<img src="uml05.jpg" alt=""><br>

Relación de Composición<br> 
Similar a la agregación, solo aporta semántica a la relación al decir que además 
de “agregar”, existe una relación de vida, donde elementos de B no pueden 
existir sin la relación con A.  <br>
<img src="uml06.jpg" alt=""><br>
<img src="uml07.jpg" alt=""><br><br>
1) Un atributo de tipo array para contener todos los elementos<br>  
2) Por lo menos un método para agregar los elementos al array, que generalmente 
se representa con un simple “add” (que como siempre queda sujeto a variar según 
nuestro criterio). <br>

Ejemplo de traducción a código<br> 
Universidad.php<br> 

<script src="https://gist.github.com/4377463.js"></script>

¿Qué relaciones se deberían evitar? <br>
<p>
Las relaciones bidireccionales y las relaciones cíclicas, ya que la visibilidad 
es en ambas partes (A y B) y un cambio en una clase genera un impacto en la otra 
y viceversa, logrando una inestabilidad muy peligrosa. 
</p>
<script src="https://gist.github.com/4377467.js"></script>

“Navegabilidad”<br> 
La lectura que debe hacerse al interpretar los diagramas es:<br> 

<img src="uml08.jpg" alt=""><br>

“Definición de Roles”<br> 
Las relaciones tienen nombre: “tiene”, “contiene”, “fabrica”, etc. <br>
<b>A -tiene-> B </b><br>

“Multiplicidad”<br> 
Parte de la documentación de UML, en una relación A->B, poder especificar la 
cantidad de objetos de B que se pueden ver en A <br>

Por ejemplo: <br>
- 1 <br>
- 1..*    <br>
- 0..*<br> 
- 3..14 <br>
<p>
Donde en el primer caso decimos que en A veremos siempre un objeto de B, en el 
segundo caso “uno o muchos”, en el tercer caso “ninguno o muchos” y el en 
último caso “de 3 a 14”. 
</p>
<b>la dependencia es una relación más débil que la asociación  </b><br><br>

http://ar2.php.net/manual/es/language.oop5.magic.php<br><br>

<b>“__”  </b><br><br>

index.php:<br> 
<script src="https://gist.github.com/4377474.js"></script>

<b>“por valor”</b><br><br>

<b>“por referencia”</b><br><br>

<b>todos los objetos son siempre “por referencia”</b><br><br>

<script src="https://gist.github.com/4377481.js"></script> 

<p>
El var_dump final no mostraría al hermano, ya que cuando se envió por parámetro, 
pasó por valor y lo que cambió fue solo eso, no el objeto original, y fuera de 
la función, no ocurrió nada.
</p>
<script src="https://gist.github.com/4377482.js"></script>
<p>
Todo esto cambia cuando usamos por defecto “pasaje por referencia” (lo que 
ocurre en PHP5), ya que si pasamos un objeto es la referencia a este y no 
importa donde estemos, si cambia, estamos cambiando el objeto original (y único).  
Se deberá entender entonces que no es necesario retornar nada cuando modificamos 
un objeto dentro de una función. 
</p>
Perro.php:<br> 
<script src="https://gist.github.com/4377487.js"></script>
Que es lo mismo decir (y funciona):<br> 
<script src="https://gist.github.com/4377493.js"></script>

<b>toString es un método público, pero que no hace falta ejecutar literalmente</b><br><br>

<script src="https://gist.github.com/4377497.js"></script>
} 
<p>
“El método reservado "toString()" es la forma que todo lenguaje POO tiene para 
que nosotros los desarrolladores podamos definir cómo convertir un objeto en 
"texto plano".” 
</p>
<script src="https://gist.github.com/4377503.js"></script>

<script src="https://gist.github.com/4377509.js"></script>

Lo fundamental de este ejercicio es comprender:<br> 
- Las distintas relaciones entre clases y su representación en código <br>
- Reafirmar que los objetos pasan siempre por referencia y no se necesita ser 
retornados o en determinados casos, ni siquiera un orden específico en sus 
asignaciones, ya que siempre estamos tratando con una referencia al mismo objeto 
(no copias).<br> 
- La importancia del “index” como concepto de punto de partida de resolución del 
problema general. <br>
- El uso correcto del toString(), más allá de lo sintáctico, cual es el concepto 
que debemos tener en cuenta a la hora de definirlo.<br><br> 

-Saber el contenido de todas las camionetas <br>
- Saber el contenido de una camioneta <br>
- Poder buscar a un niño y saber en qué camioneta está <br>
- Representar como Personas al conductor y al ayudante <br>
- El diagrama UML no debe tener información de tareas anteriores (no va ni 
perro, gato, etc)<br> <br>

<b>“todo objeto hereda de un objeto llamado Object”</b><br><br>

<b>“eliminar los números mágicos" </b><br><br>

<script src="https://gist.github.com/4377516.js"></script>
<p>
Navegabilidad se le dice al camino que debemos hacer para obtener la información 
necesaria a partir del diseño de los objetos del problema y sus interacciones.
</p>
<b>Escuela -> Coche -> Niño</b><br><br>

- La escuela “conoce” a los niños <br>
- Los niños “conocen” a sus camionetas <br><br>

<b>para un sistema “Orientado a Objetos” la unidad de trabajo son siempre “objetos”</b><br><br>

para la búsqueda de un Alumno, si lo encontramos, debemos retornar la instancia 
del objeto, de lo contrario retornamos “null” (como estándar de “no encontrado”)<br>

Si se agrega desde A la clase B, simplemente es: <br>
 
  <b>$a->agrego(b);</b><br> 

Y si se necesita retornar la clase B desde A, es simplemente <br>
 
   <b>$claseB = $a->retornoB(); </b><br>

<script src="https://gist.github.com/4377536.js"></script>

una referencia con un “return”<br>
<p>
si se requieren dos veces una clase, con “_once” solo trae en el primer intento, 
en los otros casos da error por repetir la definición de una clase
</p>
<p>
“include” no es lo mismo que “require”: el primero da un warning y sigue, 
el segundo falla y no continúa 
(“requerir” es más fuerte, nuestra clase no puede continuar si le faltan sus 
partes). 
</p>
<p>
Para simplificar la creación de múltiples instancias, muchas veces se omite la 
variable temporal que luego es asignada a otro objeto 
</p>
Ejemplo<br>
<script src="https://gist.github.com/4377550.js"></script>

http://www.php.net/manual/es/language.types.type-juggling.php<br><br>

<img src="uml09.jpg" alt=""><br>

Ejemplo de cómo sería la creación interna de un objeto, sin necesidad que esté 
creado en el exterior para luego recibirlo por parámetros<br>: 

Nino.php<br>: 
<script src="https://gist.github.com/4377585.js"></script>

1. La empresa registra primero a las personas que van a contestar la encuesta <br />	 
2. Posteriormente se le asigna una encuesta a la persona; existe una encuesta 
para cada sexo. <br />
3. La encuesta está compuesta por varias preguntas <br />
4. Se requiere saber en todo momento cuales preguntas fueron respondidas <br />
5. Y si estas fueron correctas o no <br />
6. Finalmente, tener un resumen del resultado de cada encuesta. <br /><br />

1. Crear las clases con sus atributos a partir de los requerimientos <br />
2. Relacionar las clases según lo que necesitamos cumplir de acuerdo con los requerimientos. <br />
3. Agregarle los métodos a cada Clase según la responsabilidad que detectamos 
debería tener cada una y sus relaciones con las demás clases de la solución. <br />

“Persona tiene Sexo” <br />
- La pregunta tiene –por lo menos- que tener un texto. 
- La respuesta tiene –por lo menos- que registrar el texto que responde la 
Persona.<br /> 
<p>
La asignación es simplemente una relación entre una persona y una encuesta, que 
exista una para cada sexo en sí no se representaría a través de las relaciones 
en el diagrama, solo es una regla a tener en cuenta (que hay que documentar) a 
la hora de crear Encuestas.
</p>
<b>“agregación de encuestas” </b> <br /><br />

<b>“La encuesta está compuesta por varias preguntas”</b> <br /><br />

En esta situación podríamos llegar a documentar que las preguntas no tienen 
sentido de existir si no están relacionadas con la encuesta. <br />

<b>
“Se requiere saber en todo momento cuales preguntas fueron respondidas”</b> <br />
<br />

También podemos decir que las respuestas no deberían existir si no existe una 
asociación con la Persona (composición) <br />

Definir Index: ¿qué necesitamos para armar el sistema? <br />

1. Creo la Empresa <br />
2. Podemos decidir que crear una encuesta y sus preguntas es completamente 
problema de la Empresa, por lo tanto cuando se cree la empresa ya existirá una 
encuesta con sus preguntas. <br /> 
3. Creo a la Persona y le pido una Encuesta a la Empresa y se la asigno a la 
Persona (para poder ubicar a una encuesta determinada se le agrega un atributo 
“nombre”). <br />
4. Posteriormente solicito las preguntas de la encuesta y las recorro <br />
5. Por cada Pregunta simulo una respuesta hipotética de una persona, por lo 
tanto registro en la Persona qué pregunta estoy respondiendo y mi respuesta 
(recordar, la persona ya tiene asociada a qué encuesta corresponde las 
respuestas y las preguntas, solo tendremos una encuesta por persona). <br />
6. Hacer un resumen de las preguntas que fueron respondidas, para ello hay que 
preguntarle a la persona qué preguntas respondió. Si fueran muchas personas se 
le puede pedir a la Empresa que recorra a las personas y le pregunte a cada una 
lo mismo. <br />

Index creado a “prueba y error” <br />
<p>
Si se hicieron todas las relaciones y a “prueba y error” se creó la clase Index 
y no se sabes cómo definir correctamente las relaciones, se puede simplemente 
buscar todos los “new” y estos representarán 
todas las dependencias de este contexto. 
</p>
Resultado final, Index en este diseño dependería explícitamente de: <br /> 
require_once 'Empresa.php'; <br />
require_once 'Persona.php'; <br />
require_once 'Respuesta.php'; <br />

-Es mejor que las clases conozcan lo menos posible de los componentes de otras 
clases a las que usa. <br />
-Tampoco es bueno complicar un diseño por intentar esconder absolutamente todas 
las clases e intentar que exista una única relación contra una sola clase <br />
-A pesar que enviemos los datos por parámetros y no un objeto ya creado, 
“conceptualmente” esos datos son “el objeto”. <br />
-Cada vez que una clase tiene un “new” de otra clase, indudablemente hay una 
flecha que sale hacia esa clase y tiene que haber un correspondiente 
“require_once” que represente en el código esta relación. “New” y “require_once” 
van juntos, siempre. <br />

<b>el “polimorfismo”, considerado “el patrón estratégico más importante de la POO”</b>
<br />
<br />

<h3>La Herencia </h3>
Definición: <b>“es una relación de parentesco entre dos entidades” </b>(una es padre de la otra, una es hija de la otra) <br />
<p>
La representación en UML es una “flecha continua” que va desde la clase “hija” 
hasta la clase “padre”, similar a la relación de “asociación”, pero con la 
diferencia que termina con una punta en forma de triángulo. 
</p>

<img src="uml10.jpg" alt="" /> <br />

1. Todos los atributos y métodos se heredan del Padre al Hijo, pero… <br /> 

2. Los atributos y métodos que son de tipo “público” (public) o “protegido” 
(protected) son visibles directamente desde el Hijo (en el caso particular de 
“público” son visibles de todos lados, incluyendo desde el exterior del objeto). <br />

3. Los atributos y métodos que son de tipo “privado” (private) se heredan del 
padre a su hijo pero no son “visibles” de forma directa, solo se podrá hacer a 
través de métodos del padre que sean públicos o protegidos. <br /> <br />

http://ar.php.net/manual/es/language.oop5.visibility.php <br /><br />

Caso 1 –Usuario hereda de Persona <br />

<script src="https://gist.github.com/4377588.js"></script>

<img src="uml11.jpg" alt="" /> <br />


<script src="https://gist.github.com/4377595.js"></script>
<p>
Usuario será aceptado sin ningún problema por el “Type Hinting / Validación de 
Tipo” reconoce al usuario como un tipo de Persona, lo cual es válido y permite 
su ingreso al método “imprime”. 
</p>
Caso 2 –Persona agrega un constructor <br />
<p>
Repasando: si el hijo no define su constructor, igual que sucede con  el 
toString, el destructor, etc, estos serán heredados de su Padre y sí son 
ejecutados de forma automática. 
</p>
Si el usuario define su propio constructor: <br /> 

<script src="https://gist.github.com/4377598.js"></script>

<p>
Aquí, la clase usuario visualiza el método público de su padre, pero no ve 
directamente los  atributos privados, pero, como ahora “Usuario es una Persona”, 
aunque no podamos “manipular directamente” los atributos, estos están ahí. 
</p>

<img src="uml12.jpg" alt="" /> <br />
Caso 3 –Persona agrega su toString  <br />
<p>
Definamos que Usuario es una Persona y que además de tener todos los datos de 
ella, se define ahora en la clase Padre el método toString
</p>
Persona.php: <br />
 
<script src="https://gist.github.com/4377600.js"></script>

Usuario.php: <br />
<script src="https://gist.github.com/4377607.js"></script>

index.php: <br />
<script src="https://gist.github.com/4377609.js"></script>

<p>
La explicación es que, a diferencia que el constructor, el toString se hereda 
porque es público pero este se ejecuta de forma automática, sin necesidad de 
explicitar como en el anterior caso (constructor). 
</p>
<p>
 Aquí es donde deberíamos entender que el principio de ocultación refuerza los 
 diseños al ocultar y cerrar el acceso a detalles internos, pero no por eso nos 
 impide poder aprovechar las implementaciones realizadas. Como es este caso, no 
 tenemos acceso a los atributos de forma directa y no podemos modificarlos, pero perfectamente podemos asignarles información y usarlos.     
</p> 
Caso 4 – Los usuarios necesitan un id y una fecha de ingreso <br />

La clase Persona sigue igual, lo que cambia es la clase Usuario y se ajusta la 
invocación desde Index: <br />

Usuario.php: <br />
<script src="https://gist.github.com/4377610.js"></script>

index.php: <br />
<script src="https://gist.github.com/4377612.js"></script>

Caso 5 – Los usuarios necesitan un id único “autogenerado” <br />
<p>
Aprovecharemos la situación para explicar los “atributos estáticos” (static), o 
lo que podríamos traducir como “atributos / métodos de Clase”. Estos elementos s
on de acceso común para todas las instancias de la misma clase.
</p>
<p>
La clase Persona sigue igual, lo que cambia es la clase Usuario y se agrega un 
atributo protegido (lo cual permitirá que una clase herede de Usuario y acceder directamente al atributo como propio) y se ajusta el constructor de la clase 
para no solicitar más el id. 
</p>
Usuario.php: <br />
<script src="https://gist.github.com/4377618.js"></script>

La forma de acceder al atributo estático es usando self::$atributo <br />

index.php: <br />
<script src="https://gist.github.com/4377622.js"></script>

Explicación sobre la visibilidad de los atributos y métodos <br />

Existen tres posibilidades: público, privado y protegido. <br /> 

“Visibilidad Pública” <br />
<p>
Se puede considerar como “sin restricciones”, lo que es público todos lo pueden 
acceder o modificar.  
</p>
“Visibilidad Privada” <br />
<p>
Un punto intermedio entre lo privado y lo público, lo “protegido” son los 
atributos y métodos que pueden ser accedidos de forma directa como “propios” 
por parte de los “hijos” de la clase “padre”. Para las clases que no tienen una 
relación de parentesco su significado es igual al de privado. 
</p>
Caso 6 – Ejemplos varios <br />

<h3>Clase abstracta </h3>
<p>
Técnicamente lo que hacemos definir que la clase no puede ser instanciada, por 
lo que se le antepone a “class” la palabra “abstract” y en UML se representa con 
el nombre de la clase en cursiva ó agregando un “estereotipo” (texto que va 
arriba del nombre de la clase entre <<>>). 
</p>
<p>
Conceptualmente lo que estamos diciendo es que la clase no puede ser usada 
directamente y que nos servirá de molde para crear otras clases que sí serán 
concretas y candidatas a instanciar. 
</p>
<script src="https://gist.github.com/4384802.js"></script>
 
Lo cual impide hacer  <br />
 
<script src="https://gist.github.com/4384815.js"></script>

<h3>Herencia Múltiple </h3>
<p>
La mayoría de los lenguajes POO no implementan la herencia múltiple, no porque 
les falte, se considera que lo único que aporta es más posibilidades de errores 
en los diseños. 
</p>

<h3>“Sobre-escritura” de métodos</h3>  
<p>
Otro elemento del lenguaje es poder sobre escribir un método que heredamos de 
nuestro padre. Esto se puede hacer simplemente volviendo a definir en la case 
“hija” un método con el mismo nombre.  
</p>
<script src="https://gist.github.com/4384820.js"></script>  

Evitar la herencia y la “sobre-escritura” de métodos <br />

“final”, la que impide la herencia de la clase o la sobre-escritura del método, 
de acuerdo en donde lo apliquemos <br />

Impedir heredar la clase Admin <br />
 
<script src="https://gist.github.com/4384823.js"></script>
 
Impedir alterar un método que pueda ser heredado <br />
 
<script src="https://gist.github.com/4384824.js"></script>

<h3>“Generalización” versus “Especialización”</h3>
<p>
Por ejemplo, imaginemos que solo contamos con la clase Persona y descubrimos que 
necesitamos una clase Usuario, podemos decir entonces que a partir de Persona 
hicimos una “especialización” al crear la clase Usuario, ya que tomamos un 
comportamiento más genérico y lo adecuamos a una clase mucho más concreta y 
aplicable a entornos más particulares. 
</p>
<p>
Imaginemos lo contrario, contamos con dos clases que están al mismo nivel, sin 
relaciones entre ellas, que son Usuario y Admin, ambas clases repiten muchos 
atributos y métodos (como nombre y apellido), por lo que decidimos hacer una 
“generalización” y creamos una clase Persona haciendo un factoreo de todo lo 
común entre ambas clases. 
</p>
<p>
En resumen: podemos decir que son dos formas distintas de referirnos a la 
relación de “herencia”. 
</p>
Entonces, ¿qué es Polimorfismo? <br />
<p>
En sí la palabra solo refiere a “muchas formas” y aplicado a la POO es la 
capacidad de poder tomar varias clases que tiene operaciones iguales y poder 
invocar a cualquier instancia el mismo método común. 
</p>
<p>
Ventajas: Poder hacer un diseño genérico que se apliquen a varios objetos que 
tienen operaciones comunes. 
Definamos el siguiente contexto: tenemos una clase Impresora que se encarga de 
recibir cualquier cosa y la imprime con un “echo”(a futuro podrá ser una 
impresora). 
</p>
<script src="https://gist.github.com/4384825.js"></script>

La implementación <br />
index.php <br />
 
<script src="https://gist.github.com/4384832.js"></script>

Impresora.php <br />
 
<script src="https://gist.github.com/4384835.js"></script>
Informe.php <br />
 
<script src="https://gist.github.com/4384841.js"></script>
<p>
Bien, sin darnos cuenta y casi sin necesidad de entenderlo, estamos haciendo uso 
del polimorfismo. Nuestra clase de impresión recibe distintos tipos de objetos 
que comparten el mismo nombre común de un método que se requiere para que la 
impresora pueda funcionar. En distintas etapas de nuestro sistema veremos 
distintas instancias haciendo uso del mismo código de impresión: “polimorfismo”, 
“muchas formas”. 
</p>
“Diseño más robusto” <br />

- Aplicamos una “generalización” buscando lo común de ambas clases y creando una 
clase “Hoja” que tendría toda la información base para cualquier documento que 
quiera imprimirse. Por defecto la hoja sabe imprimirse, y en caso de necesitar 
modificar el comportamiento, sobre-escribiremos el método imprime en la clase 
concreta (Currículum o Informe). <br />
- Se agrega el tipo “Hoja” en el método imprimir de la clase Impresora, por 
consiguiente no permitirá a ningún objeto que no sea de tipo “Hoja” pasar 
por allí.<br />

Bien, esto es el tradicional “polimorfismo por herencia”. <br />

¿La herencia está limitada? <br /><br />

http://ar.php.net/interface<br /><br />

<h3>Las interfaces: “el poder desconocido”</h3>
<p>
Las interfaces son similares a la herencia: la herencia “agrupa” clases que 
“son lo mismo” (relación de parentesco) y la interface “agrupa” clases que 
“que realizan las mismas operaciones” (pero no necesariamente son iguales). 
</p>
Implementación <br />
 
ImprimibleInterface.php <br />

<script src="https://gist.github.com/4384844.js"></script>

Curriculum.php <br />

<script src="https://gist.github.com/4384848.js"></script>

Impresora.php <br />

<script src="https://gist.github.com/4384852.js"></script>

index.php <br />

<script src="https://gist.github.com/4384855.js"></script>

Cómo funciona <br />

1. Inmediatamente que agregamos el tipo Imprimible en el método de la Impresora, 
cualquier objeto que quiera pasar por ahí deberá implementar la interface 
Imprimible. <br />
2. Una vez que lo implemente, el compilador de PHP le dirá que su clase no 
tienen el método “imprime” (esto lo obliga la interface, usted no la está 
cumpliendo), por lo tanto para que pueda ser aceptada tiene que contar con ese 
método. <br />

- La flecha es similar a herencia, solo que es “punteada” (“discontinua”), en 
vez de decir “hereda” debemos decir “realiza/implementa/cumple” con la interfaz. <br />
- Todos los métodos de la interfaz son “firmas”, es decir, solo va el nombre y 
la lista de parámetros, no existe implementación, ni siquiera van las llaves {}. <br />

Las interfaces son “contratos de implementación” <br />

Una interface es conceptualmente lo que se dice un “contrato de implementación”, 
ya que para usar un servicio (Impresora) tiene que cumplir un contrato 
(interfaz) que lo obliga a cumplir una serie de requisitos (las firmas de 
métodos que aparecen en la interfaz). <br /><br />

http://phpsenior.blogspot.com/2007/10/herencia-de-clases-y-el-principio-de.html<br /><br />

http://phpsenior.blogspot.com/2006/08/herencia-mltiple-en-php5.html<br /><br />

Resumen <br />
 
Hicimos la primer introducción a la Herencia y las Interfaces, las diferencias 
entre ambas, y cómo se aplica el polimorfismo y los distintos tipos que hay. <br />
También destacamos que conceptualmente el Polimorfismo es un 
“patrón estratégico” y que las interfaces son “contratos de implementación”. <br />

Ejercicio  “Clase de Persistencia” <br />

Se necesita diseñar e implementar una clase de persistencia genérica llamada 
BaseDeDatos que pueda recibir distintos tipos de "Manejadores de Base de Datos" 
como ser MySQL, Postgres, etc, desde su constructor. Para ello deberán hacer uso 
de las interfaces, creando una que se llame ManejadorBaseDeDatosInterface y que 
tenga en su "contrato de implementación" las operaciones más básicas y 
elementales: conectar, desconectar, traer datos ejecutando una consulta SQL, 
etc. <br />
Posteriormente y para dividir responsabilidades, necesito que creen una clase 
SQL que se encargue de procesar todos los pedidos SQL en partes, así poder a 
futuro hacer mayores controles. <br />
 
Por ejemplo, debería tener métodos como: <br />
- addCampo <br />
- addTabla <br />
- addWhere <br />
- addOrder <br />
- etc <br />

<script src="https://gist.github.com/4384859.js"></script>
<p>
Con “Persistencia” nos referimos tanto a guardar como recuperar datos de un 
medio de almacenamiento permanente, por defecto hablamos de una base de datos, 
pero perfectamente podría ser un archivo de texto plano u otro medio. 
</p>
<b>"Cualquier problema en computación puede resolverse añadiendo otra capa de 
abstracción" </b>
<br />
<br />

Primer escenario: “crear una conexión a la base de datos”<br />

buscamos cada una de las sentencias en el manual y  en el peor de los casos 
nuestro código se plaga de sentencias tan específicas como:  <br />
mysql_connect, mysql_query, etc. <br />

Segundo escenario: “crear una clase de persistencia” <br />

Tratando de prever esta situación podríamos crear una “nueva capa de 
abstracción” y generar un clase genéricas (conectar, traer datos, desconectar) 
que nos permita “esconder” el código específico de MySQL. En caso de necesitar 
alguna funcionalidad extra o cambiar de motor, simplemente el impacto en 
nuestro sistema estaría reducido a modificar nuestras funcionalidades de una 
clase que oculta los detalles de implementación. <br />

Tercer escenario: “abstraer el tipo de base de datos”<br />

Imaginen que nuestro producto crece y lo empezamos a comercializar para muchas 
plataformas, y que uno de nuestros nuevos requerimientos es poder contemplar 
varios motores de bases de datos. Para ello tenemos que “contener el foco de 
cambio”(*) y adaptar a nuestro sistema para que solo agregando “código nuevo sin
modificar lo existente”  pueda así soportar más motores de bases como Oracle, 
MSSQL Server, Informix, Sybase, Firebird, etc, etc. <br />

Foco de cambio: se le dice al lugar o lugares de nuestro sistema que por 
los requerimientos que estamos desarrollando, es seguro que ahí habrán cambios 
(agregar, modificar, etc) por consiguiente debemos preverlo de alguna forma para
bajar su costo de modificación / mantenimiento. <br />

index.php <br />
<script src="https://gist.github.com/4384863.js"></script>


ManejadorBaseDeDatosInterface.php <br />
<script src="https://gist.github.com/4384866.js"></script>


BaseDeDatos.php <br />
<script src="https://gist.github.com/4384870.js"></script>


MySQL.php <br />
<script src="https://gist.github.com/4384871.js"></script>


Sql.php <br />
<script src="https://gist.github.com/4384874.js"></script>

Principio de diseño “Abierto / Cerrado” <br />

nuestro costo en el desarrollo se da cuando diseñamos un sistema que cuando hay 
cambios de requerimientos debemos modificar constantemente, por lo tanto un 
buen diseño deberá ser “Abierto / Cerrado”, se diseñará una vez y cuando se 
necesite agregar nueva funcionalidad se hará sin modificar el código existente, 
solo agregando código nuevo<br />

Se dice que todo buen diseño (como las implementaciones de los  Patrones de 
Diseño) de alguna forma u otra termina cumpliendo con este principio. <br />

Pasando en limpio: cada vez que necesitemos soportar otro motor de base de datos 
crearemos una nueva clase, requerimos la interfaz (“contrato de implementación”) 
y esta nos obligará a implementar los métodos requeridos para que todo funcione 
de acuerdo al diseño. <br />

Recuerda: trata de mecanizar esta buena práctica, una clase que ofrece un 
servicio debe implementar en conjunto una interfaz que servirá de guía para 
todas las clases que quieran usar ese servicio. <br />
<img src="uml_persistencia.jpg" alt="" />
<br>
<h3>Ejercicio “Librería y la búsqueda de Libros” </h3>
<p>“Tengo una librería y estoy implementando un sistema para registrar libros. Actualmente mi 
principal problema es la búsqueda de los libros, ya que sé que luego de implementado mi 
sistema de búsquedas me pedirán agregar nuevos filtros de información (he detectado el "foco 
de cambio"), por lo tanto deberé contemplar en el diseño este problema.” </p>
<img src="uml13.jpg" alt="">  <br>
El diseño debe poder soportar las siguientes búsquedas:<br> 
- Todos los libros de un año: 2008 
- Todos los libros del autor llamado "Enrique Place"<br> 
- Todos los libros del tema "PHP" <br>
- Todos los libros que tengan en su título la palabra "Java" (deberán buscar la coincidencia parcial).<br>
<br>
- Index no ve directamente a los libros<br> 
- Index no ve directamente a los Autores<br>
<p>El objetivo de este ejercicio es completar el entendimiento de cómo funcionan las interfaces,  cómo se 
aplica el principio de diseño “Abierto / Cerrado”  y cómo se pueden implementar las relaciones en 
situaciones donde el acoplamiento es alto entre las clases de la solución. </p> 
<h3>Diseño “Final” cumpliendo con todos los requerimientos </h3>
<img src="uml14.jpg" alt="">  <br>
Agregados<br>
- Se agrega la firma del método en la interfaz CriterioFiltro <br>
- Los nombres de las clases Filtro y sus atributos <br>
- Se obvian todos los get, set, constructores y toString del diagrama ya que se considera que el 
lector objetivo es un desarrollador que sabe determinar cuándo necesitarlos implementar (para 
este diagrama no aportan detalles relevantes). <br>
- Se agrega en Libro un método getAutores para poder obtener luego su lista de autores.<br>
index.php: <br> 
<script src="https://gist.github.com/4384882.js"></script>
Comentarios sobre el diseño  <br>
- Se requieren exactamente las clases que dice el diseño UML, ni más ni menos. <br>
- Se cargan libros y autores sin acceder desde Index a las clases Libro y Autor, todo a través de la 
clase Librería.  <br>
- Este diseño permite tener un solo diseño de búsqueda y poder intercambiar fácilmente los 
algoritmos de los criterios de búsqueda.<br> 
- El principio Abierto / Cerrado nos dice que un buen diseño es “cerrado al cambio y abierto a la 
extensión”, en este caso el “foco de cambio” será agregar nuevos criterios de búsqueda, tema 
que está resuelto “agregando solo código nuevo”.<br>
Libreria.php: <br>
<script src="https://gist.github.com/4384885.js"></script>
Comentarios<br>
- La clase Librería sólo requiere Libro, no requiere directamente la clase Autor <br>
- La búsqueda se realiza recibiendo un criterio y este criterio va recibiendo cada uno de los 
ítems de la colección de libros, cada vez que el libro coincida con el criterio de filtro este 
método retornará “true”, por lo tanto lo guardaré en un array para luego devolver a todos los 
objetos Libros encontrados. El filtro sólo tiene una responsabilidad, confirmar si se cumple el 
criterio o no. <br>
- Para agregar un autor de un libro se hace una búsqueda y posteriormente se le da todos los 
datos al libro para que guarde su autor, todo sin tener que crear una instancia a este nivel. <br>
Libro.php: <br>
<script src="https://gist.github.com/4384890.js"></script>
Comentarios<br>
- El Libro sólo conoce al Autor<br> 
- En el UML se obvian todos los get y toString por considerarlos triviales a la hora de abordar el problema real. <br>
Autor.php: <br>
<script src="https://gist.github.com/4384895.js"></script>
CriterioFiltro.php: <br>
<script src="https://gist.github.com/4384897.js"></script>
FiltroAutor.php: <br>
<script src="https://gist.github.com/4384901.js"></script>
<hr>
<h3> “Los Paquetes en UML”</h3>
<p>Los paquetes son la representación de un agrupador de clases (o de otros paquetes) en un 
sistema Orientado a Objetos, lo que generalmente se traduce físicamente en un directorio .</p>
Cómo se representan <br>
En UML se hace gráficamente con el dibujo de una "carpeta" como representación del concepto de "agrupador de clases".   <br>
<img src="uml15.jpg" alt=""><br>
La clase Index se encuentra en la raíz de nuestro proyecto, y la relación siempre con y entre los paquetes es de "dependencia". <br> 
Aquí tenemos un nuevo nivel de abstracción donde "conocemos" que nuestra clase Index depende de un paquete "Lógica" (que a dentro contendrá clases) y que a su vez el paquete de Lógica depende del paquete de "Dispositivos". <br>
<h3>¿Qué es una Arquitectura de 3 capas? </h3>
<b>No es más que crear 3 paquetes con nombres como: presentación, dominio y persistencia, y darle a 
cada uno una responsabilidad concreta.</b><br>
La regla será que siempre deberán entrar las peticiones desde 
la interfaz (lo que usa el usuario), pasar por el dominio (donde realmente se resuelve el sistema) y 
finalmente la capa de persistencia (donde se guardan o recuperan los datos).<br>
Cada capa recibe una petición de la otra, si alguna no tiene nada que hacer con ella, simplemente juega 
de "pasamanos" para la capa correspondiente según su responsabilidad. <br>
<img src="uml16.jpg" alt=""><br>
<h3>¿Que son entonces los Namespaces? </h3>
- Java tiene la sentencia "import" que 
permite definir el paquete en el cual 
pertenece la clase en cuestión y a su vez 
incluir él o los paquetes que 
necesitamos acceder desde una clase 
particular. <br>
- En .Net, por ejemplo con Visual Basic, 
el nombre cambia a "namespace" y a 
pesar que sirve para implementar los 
"paquetes", es un concepto un poco 
más amplio : permite definir que una 
clase es parte de un paquete, 
independientemente de donde se 
encuentre físicamente el archivo de la 
clase, por lo que podríamos tener varios 
archivos distribuidos en un sistema pero 
ser parte del mismo "paquete".<br><br>
http://phpsenior.blogspot.com/2006/04/php5-diseo-en-3-capas-y-problemas-con.html<br><br>
http://ar2.php.net/manual/es/language.namespaces.php<br><br>
<p>Los paquetes permiten un nuevo nivel de abstracción y que podemos usar para definir una 
arquitectura dividida en 3 capas, que no es más complejo que separar físicamente los archivos de las 
clases bajo el criterio único de la responsabildad de la capa.</p>
<h3> Ejercicio “Programación ‘Orientada a la Implementación’ vs ‘Orientada a la Interface’"</h3>
<br>
<hr>
http://phpsenior.blogspot.com/2006/04/programacin-orientada-la-implementacin.html
<hr>
<p>Supongamos que tenemos un sistema que hará las funciones de "máquina de escribir", donde obtendrá información a través de un dispositivo de entrada y luego enviará esta información a un dispositivo de salida.</p>
<img src="dise_o_paquetes.jpg" alt=""><br>
Nuestro diseño estará compuesto por dos paquetes (en el contexto UML) que nos ofrecen los siguientes servicios:<br>
<b>Lógica</b>: donde tendremos la implementación de "alto nivel" de nuestro problema (donde se manipularán los dispositivos).<br>
<b>Dispositivos</b>: donde la implementación de nuestro paquete de "lógica" tendrá acceso a servicios de "bajo nivel" provisto por este paquete.<br>
<img src="dise_o_paquetes_class.jpg" alt=""><br>
Entrando en el diseño interno de los paquetes, tendremos:<br>
- Dentro del paquete "Dispositivos": las clases "Teclado", que retornará información en formato de texto, e "Impresora", que en algún momento recibirá un texto para ser impreso.<br>

- Dentro del paquete "Lógica": la clase "MaquinaDeEscribir", que se encargará de crear las instancias correspondientes a los dispositivos de entrada/salida, y pasar la información que devuelve una clase a otra clase.<br>
Imprementación<br>
Seguiremos textualmente los diagramas UML para hacer la codificación de nuestras clases.<br> 
Empezaremos con los dispositivos.<br>
Archivo: Teclado.php<br>
<script src="https://gist.github.com/4384905.js"></script>
Archivo: Impresora.php<br>
<script src="https://gist.github.com/4384910.js"></script>
Archivo: MaquinaDeEscribir.php<br>
<script src="https://gist.github.com/4384920.js"></script>
¿Cómo se prueba?<br>
Una posible solución creativa, tratando de llevar a PHP hacia un lenguaje 100% Orientado a Objetos (como Java), donde *todo* debería ser un objeto, se usará el "index.php" como una clase "Index".<br>
<script src="https://gist.github.com/4384928.js"></script>
Programación Orientada a la Interface<br>
<p>En el caso anterior, la clase de "alto nivel" dependía de dos clases de "bajo nivel", lo que significa algo muy grave: "la clase de alto nivel es *dependiente* de los cambios que puedan sucederle a las clases de bajo nivel, es decir, nuestro alto nivel depende de los detalles de implementación del bajo nivel".</p>
El problema de nuestro diseño es que estamos programando "orientado a la implementación"<br>.
¿El diseño anterior, puede considerarse un buen diseño?<br>
-¿Cuan mantenible será nuestro sistema si elementos de bajo nivel pueden generar cambios en todo el modelo?  <br>
-¿Es correcto que nuestra MaquinaDeEscribir dependa de cómo se toman los datos y de cómo se imprimen?<br>
-¿Qué es lo más importante en nuestro diseño? ¿la Lógica o los Dispositivos?<br>
-¿Este diseño, es reutilizable? ¿podemos reutilizar el MaquinaDeEscribir en otros contextos?
-¿Su costo de mantenimiento es alto o bajo? ¿cuanto código hay que agregar para extender su comportamiento (para cubrir un nuevo requerimiento)?<br>
-¿el código presentado se mantiene, o hay que adaptarlo cada vez que queramos extender su funcionamiento?    <br>
<hr>
<p>Index usa la clase MaquinaDeEscribir.php que se encuentra dentro del paquete"logica", por 
consiguiente, desde la vista de paquetes, Index depende del paquete "logica", y como dentro 
de lógica la clase MaquinaDeEscribir depende de dos clases que están dentro del paquete 
"dispositivos", el paquete "logica" (donde está MaquinaDeEscribir), depende del paquete 
"dispositivos". </p>
Requerimientos<br>
Enunciado:"La máquina de escribir tiene un dispositivo de entrada de datos (teclado) y un 
dispositivo de salida de datos (impresora)"<br> 
 
Como convención los nombres de paquetes son siempre en minúsculas y se traducen como un 
subdirectorio en nuestro sistema como forma de organizar nuestras clases. <br>
<img src="uml17.jpg" alt=""><br>
Lo que solicita el ejercicio es: <br>
1. Dos implementaciones que deberán llamarse version1 y version2 <br>
2. La primera tendrá la programación "orientada a la implementación", deberán 
completar el diagrama presentado y hacer su implementación. <br>
3. La segunda deberá ser programación "orientada a la interfaz" (como dice su nombre, 
usando "interfaces"), también deberán hacer el diagrama e implementación de la 
solución (todo de acuerdo a los conceptos vertidos en el artículo presentado 
oportunamente en el blog):<br> 
4. Deberá depender de las interfaces y no de las clases concretas. <br>
5. Finalmente, cuando el diseño esté completamente terminado, ver la forma de 
solucionar un problema en el diseño: cambiar la dependencia entre los paquetes, ya 
que la lógica no debería depender de los detalles de implementación de los dispositivos, 
sino, los dispositivos cambiar en caso de que la lógica cambie ("lo menos importante 
depende de lo más importante").<br> 
Solución<br>
<p>La primera parte, repasar el concepto y la forma de requerir las clases y cómo hacerlo en caso 
de tener subdirectorios  (representados en UML como “paquetes” para agrupar clases). </p>
<p>La segunda parte, buscaba seguir aplicando con ejemplos por qué cada vez que 
implementamos un “servicio” debemos de forma casi mecánica incluir una interfaz para dejar el 
camino definido a cualquier clase que necesite usar ese servicio. </p>
<h4>Parte 1: hacer una “máquina de escribir” siguiendo el ejemplo del artículo </h4>
El diseño UML  era el siguiente: <br>
<img src="uml18.jpg" alt=""> <br>
Y la vista de paquetes era la siguiente <br>
<img src="uml19.jpg" alt=""> <br>
<b>Implementación </b><br>
index.php <br>
<img src="uml20.jpg" alt=""> <br>
MaquinaDeEscribir.php (dentro del paquete “lógica”) <br>
<img src="uml21.jpg" alt=""> <br>
Teclado.php (dentro del paquete “dispositivos”)<br>
<img src="uml22.jpg" alt=""> <br>
Impresora.php (dentro del paquete “dispositivos”)<br>
<img src="uml23.jpg" alt=""> <br>
Conclusión <br>
Según se explica en el artículo de referencia (PHPSenior), la lectura de los diagramas y sus 
relaciones nos hacen llegar a la siguiente conclusión:   <br>
<img src="uml24.jpg" alt=""> <br>
<p>“La lógica de nuestro sistema depende de los dispositivos, por lo pronto esto significa un 
problema en nuestro diseño , ya que según el sentido de las flechas, cualquier cambio en 
nuestros dispositivos de bajo nivel afectarán el corazón de nuestro sistema” </p>
<h4>Parte 2: Agregar interfaces al diseño propuesto en la parte 1 </h4>
<img src="uml25.jpg" alt=""> <br>
Aquí separamos la clase MaquinaDeEscribir de depender directamente de las clases Teclado e 
Impresora.<br>
Hay varios detalles importantes:<br> 
- Pasamos de depender de “implementaciones concretas” a depender de 
“implementaciones abstractas”, ya que para MaquinaDeEscribir lo único con que se 
relaciona es con elementos de tipo las interfaces y no se preocupa cómo se 
implementen las clases que cumplan con el “contrato de implementación”  (es 
problema de la interfaz definir lo que se necesita y de la clase que quiere el servicio 
en cumplir los requisitos necesarios para usarlo). <br>
- Casi sin darnos cuenta estamos cumpliendo con el principio “Abierto/Cerrado”, ya 
que vamos a estar “cerrados al cambio pero abiertos a la extensión”, el “foco de 
cambio” será agregar nuevos dispositivos pero no necesitaremos modificar el 
funcionamiento de MaquinaDeEscribir, ya que su algoritmo será siempre el mismo.  <br>
Se podría decir que solo falta la flecha de Index a la clase MaquinaDeEscribir: <br>
<img src="uml26.jpg" alt=""> <br>
<p>Pero no, no es suficiente, ya que para que MaquinaDeEscribir pueda funcionar depende de que 
le ingresen dos elementos de tipo Lector y Escritor. Prestar atención, la clase 
MaquinaDeEscribir no depende directamente de las clases concretas, sí las terminará usando 
a través de polimorfismo (a esto se le llama “indirección” o “relación indirecta”: usa elementos 
concretos pero depende en realidad de elementos abstractos). </p>
El diagrama correcto debería ser el siguiente: <br>
<img src="uml27.jpg" alt=""> <br>
Implementación <br>
Lo medular de la implementación es el nuevo método “run” de la clase MaquinaDeEscribir, que 
recibe ahora dos tipos de objetos, “lectores” y “escritores”:  <br>
index.php <br>
<img src="uml28.jpg" alt=""> <br>
MaquinaDeEscribir.php <br>
<img src="uml29.jpg" alt=""> <br>
LectorInterface.php <br>
<img src="uml30.jpg" alt=""> <br>
EscritorInterface.php <br>
<img src="uml31.jpg" alt=""> <br>
Impresora.php <br>
<img src="uml32.jpg" alt=""> <br>
<p>Nota: como Impresora y la interfaz Escritor son del mismo paquete, no llevan rutas en el 
require_once que hagan referencia desde donde se ejecuta Index, ya que esta ubicación puede 
cambiar y la relación entre los paquetes debe estar fija por diseño (revisar las flechas del 
diagrama anterior).  </p>
Teclado.php <br>
<img src="uml33.jpg" alt=""> <br>
¿Y el Diagrama de Paquetes? <br>
…  ¿cómo quedará ahora la relación vista a nivel de paquetes? Viendo el sentido de las flechas y 
solo representando una flecha de dependencia (así son siempre entre paquetes) resumiendo 
todas las existentes (aumentamos el nivel de abstracción) … <br>
<img src="uml34.jpg" alt=""> <br>
Entonces, la vista de paquetes se ve así: <br>
<img src="uml35.jpg" alt=""> <br>
<p>Lo que no debe asustar es que existan dos flechas de dependencia contra el paquete desde 
Index, ya que esto es normal (para usar un servicio o conjunto de clases podremos depender de 
uno o más paquetes), lo que sí debería preocuparnos (además de evitar las relaciones cíclicas) 
es que –a pesar de haber mejorado hacia un diseño “que depende de interfaces y no de 
implementaciones concretas”- nuestro paquete de “lógica” sigue dependiendo del paquete de 
“dispositivos”…  </p>
<h4>El  “Principio de Inversión de dependencias (DIP)”</h4>
<p>¿Cómo solucionamos esto? Cambio de sentido de flechas entre paquetes  
Hay una técnica para cambiar el sentido de las dependencias entre paquetes que es  mover  las 
clases de un paquete hacia el otro paquete, o en su defecto, creando un tercer paquete y 
mover las clases para cambiar el sentido de las direcciones. Para este caso concreto, 
moveremos las interfaces a la clase que provee el servicio, por lo tanto cambiaremos el sentido 
de las dependencias entre paquetes: </p>
<img src="uml36.jpg" alt=""> <br>
<p>Nuevamente, prestar atención el sentido de las flechas de implementación, ahora apunta a las 
clases que están en el paquete de arriba (“lógica”), así que pasando en limpio el diagrama de 
paquetes ahora quedaría: </p>
<img src="uml37.jpg" alt=""> <br>
<img src="uml38.jpg" alt=""> <br>
<p>Alternativa: como solución alternativa podríamos crear un tercer paquete para las Interfaces, 
donde la lógica y los dispositivos dependerían, rompiendo la relación directa que antes existía. </p>
<b>Resumen </b><br>
Premisa: “En general, las interfaces pertenecen a las entidades que las emplean” <br>
El paquete de “lógica” conoce y tiene una interfaz para conectarse con el paquete “dispositivos”, pero 
no sabe qué hay dentro del paquete “dispositivos”. <br>
<hr />
<h3>Ejercicio “Desarrollar un sistema de ABM de usuarios” </h3>
Requerimientos <br />
"Ustedes están a prueba por la empresa SURFORCE y a modo de probar sus conocimientos para 
obtener el puesto de PHP Senior recibirán un sub-sistema que deberán concluir con todo éxito. 
 <br />
Lo que hay desarrollado hasta el momento es el esqueleto de un sistema en 3 capas que 
cumple con el siguiente UML: <br />
<img src="uml39.jpg" alt=""> <br>
<p>Lo que se deberá desarrollar en primera instancia es un sistema de ABM de Usuarios 
(Altas/Bajas/Modificaciones) con un diseño de interfaz similar a entornos como Ruby On Rails (a 
continuación un ejemplo de cómo se deberá ver la interfaz): </p>
<img src="uml40.jpg" alt=""> <br>
1. Aplicar todos los conocimientos vistos hasta el momento (Kiss es fundamental). <br />
2. Relevar todo lo existente en el sistema entregado (archivo de configuración, entender 
cómo funciona, cual es la forma de trabajo, qué falta, etc). <br />
3. Implementar todo lo necesario para cumplir el ejemplo de diseño anterior, logrando 
hacer un listado de usuarios, detalle, alta, baja y modificación de datos. <br />
4. Presentar el diagrama UML final con todos los agregados realizados. <br />
<a href="http://phpsenior.blogspot.com/2006/04/php5-diseo-en-3-capas-y-problemas-con.html">PHP5: Diseño en 3 capas y problemas con subdirectorios</a> <br />
<a href="http://phpsenior.blogspot.com/2006/07/conceptos-separar-el-cdigo-de-la-capa.html">Conceptos: "Separar el código de la capa de presentación"</a> <br />
<a href="http://phpsenior.blogspot.com/2006/04/peticin-para-soporte-de-name-spaces-en.html">"Petición para soporte de Name Spaces en PHP5"</a> <br />
Solución  <br />
<p>La idea de esta tarea es presentar un problema completo a partir de un template de un sistema existente, el cual deberían usar de apoyo para cumplir con los requerimientos solicitados. </p>
<p>A pesar que el ejercicio permite aplicar algunos conceptos aprendidos en este libro, no deja de ser un ejercicio y como tal, desborda de programación “artesanal”. Hay muchos detalles que no son tenidos en cuenta, como puede ser la seguridad del sistema o cómo procesar más eficientemente la capa de presentación en conjunto al armado de html, estilos, etc. </p>
Cambios que se aplicaron en la resolución <br />
General <br />
- Se usó el criterio de definir estático todo lo que era genérico o general de la clase, y lo 
opuesto para referirse a los métodos que se aplican a una instancia de un objeto. Es 
decir, si la clase usuario se usaba para traer todos los usuarios del sistema, debía ser 
Usuario::getAll(), y  los métodos estándar se aplicaban a una instancia única que 
representaba a “él” usuario. <br />
- Se creó un método load de la clase dominio/Usuario para una vez obtenido el id de 
usuario por parámetro, este cargue el usuario que se encuentre en la persistencia. Se 
puede decir que hace el efecto de una “fábrica” (patrón de diseño). <br />
Persistencia <br />
- Modificamos la persistencia para que retorne los datos en un array <br />
- Modificamos la clase Sql para contemplas los demás casos del ABM <br />
Dominio <br />
- Agregamos el constructor para inicializar los datos que consideramos básicos del objeto <br />
- Modificamos el getAll para que pueda retornar una colección de objetos array <br />
- Creo el toString para que cada usuario sepa cómo imprimirse cuando lo use la capa de 
presentación <br />
Presentación <br /> 
- Se armaron todos los formularios requeridos para el ABM <br />
- Se agregaron redirecciones para luego de procesar regrese a la página inicial. <br />
<b>Diagrama tradicional de paquetes </b><br />
<img src="uml41.jpg" alt=""> <br>
<b>Diagramas de clases y sus paquetes de origen </b><br />
<img src="uml42.jpg" alt=""> <br>
<b>Diagramas de Secuencia</b>
<br />
<p>Se sabe que los diagramas de clases son una “foto estática” del diseño general de una 
solución, pero no siempre es suficiente para entender cómo un diseño de clases debe trabajar, 
qué se invoca primero y qué después, para ello existen los “diagramas de secuencia” que nos 
permiten tener una visión más dinámica y temporal de cómo interactúan los objetos una vez 
que se inicia una acción determinada. </p>
Caso: Ver detalle de un usuario (ejemplo)  <br />
<img src="uml43.jpg" alt=""> <br>
<p>Aquí se pude observar cómo se van sucediendo las invocaciones de los métodos, y cómo es 
que una clase se relaciona con otra invocando los métodos de la clase siguiente. La línea 
temporal se define de arriba – abajo, el primer método que se invoca es el que hace Index al 
ejecutar UsuarioPresentacion::detalle() y sigue bajando hasta llegar a la última ejecución. </p>
Por ejemplo, <br />  
1. Index invoca el detalle() de UsuarioPresentación,  <br />
2. posteriormente este invoca el método load() de la clase Usuario y  <br />
3. finalmente este invoca el load de la clase UsuarioPersistencia (todo un “pasamanos”). <br />
<p>Aunque generalmente no se representa, al final de la cadena lo que sucede es que la última 
invocación retorna información, que recibe la clase siguiente al invocación, hasta llegar otra vez a la clase inicial (secuencia inversa): </p>
1. UsuarioPersistencia retorna datos, <br />
2.  Usuario lo recibe y arma los objetos para luego retornarlos a  <br />
3. la clase UsuarioPresentación para luego esta retornar a  <br />
4. Index, recibe lo que tiene que mostrar (html) y así ejecuta un “echo”  <br />
<h3>Partes esenciales del código de la solución </h3>
Index.php <br />
<script src="https://gist.github.com/4385103.js"></script>
UsuarioPresentacion.php  <br />
<script src="https://gist.github.com/4385106.js"></script>
Usuario.php <br />
<script src="https://gist.github.com/4385112.js"></script>
UsuarioPersistencia.php <br />
<script src="https://gist.github.com/4385118.js"></script>
<h3>Anexo: “Manejo de excepciones” </h3>
<a href="http://www.php.net/manual/es/language.exceptions.php">excepciones</a> <br />
Introducción <br />
Una excepción es una situación anormal que ocurre durante la ejecución de un sistema que 
no está contemplada en el flujo esperado de nuestro código. <br />
Debemos contemplar todas las situaciones que “no son esperadas / no son 
normales” para que nuestro sistema sepa cómo proceder en caso de fallas:  
- el servidor de base de datos está fuera de servicio,  <br />
- cambió la clave del usuario que usamos para conectarnos,  <br />
- no existe la tabla de usuarios,  <br />
- algún campo de la tabla cambió de nombre,  <br />
- etc. <br />
<p>En la programación tradicional, haríamos algo como esto (extrato del manual oficial): </p>
<script src="https://gist.github.com/4393428.js"></script>
<p>Aquí solo estamos controlando que se pudo hacer la conexión a la base de datos, pero no
los demás casos.  </p>
Podríamos agregarle entonces: <br />
<script src="https://gist.github.com/4393439.js"></script>
<h4>Básicamente cómo funcionan las excepciones  </h4>
<p>Existen dos claras zonas, la primera de “try” que se traduce cómo “intentar ejecutar el 
código que está entre llaves y que es posible que pueda fallar” y el “catch”, el código 
previsto para tratar el fallo que pueda ocurrir. </p>
<script src="https://gist.github.com/4393447.js"></script>
<script src="https://gist.github.com/4393449.js"></script>
<p>Si vienes prestando atención, el echo $e retorna información porque la 
clase Exception implementa el método toString() con el mensaje básico de error. </p>
<b>Estructura interna de una clase Exception</b> <br /> 
La estructura de una clase Exception es (según el manual oficial): <br />
<script src="https://gist.github.com/4393455.js"></script>
<p>Esto significa que podemos hacer uso de los métodos listados para poder, si así lo deseamos, generar un mensaje a medida para el usuario de acuerdo a nuestras necesidades. </p>
<p>Un ejemplo de un mensaje breve y sin menos datos: </p>
<script src="https://gist.github.com/4393462.js"></script>
<p>Tal ver preferimos dar una referencia, un código para poder completar en un formulario de asistencia técnica.</p>
<script src="https://gist.github.com/4393465.js"></script>
<script src="https://gist.github.com/4393469.js"></script>
<b>Importante: PHP no tiene excepciones por defecto </b><br />
<p>Una de las ventajas viene directamente por el paradigma POO, como las excepciones se 
representan con objetos, podemos extender la clase Exception y crear nuestras propias 
excepciones de acuerdo a nuestras necesidades.</p>
¿Cuan grave es no tener Excepciones predefinidas y por defecto? <br />
<p>Que es muy normal que lo primero que probemos sea una sentencia de conexión a una 
base de datos (como vimos al principio de este capítulo) y que las excepciones no funcionen, 
dejandonos algo confusos. </p>
Por lo tanto tenemos dos problemas: <br />
- En PHP5 debemos crearnos nuestras propias excepciones a partir de la única 
clase que nos provee el lenguaje: Exception. <br />
- Todo lo que atrapemos debemos asegurarnos que retorne una 
Excepción, y como el lenguaje no lo hace por defecto, debemos hacerlo a nivel de clases 
propias, validando internamente de la forma tradicional (if/else/switch), pero al subir de 
nivel el resto podrá hacer uso normal de los try/catch. <br />
Ejemplo funcional de excepciones en PHP5 <br />
Aquí veremos cómo hacerlas funcionar sin excepciones por defecto creando una clase genérica que tendrá todo el código del primer ejemplo donde retornaba los mensajes de error clásicos 
y los cambiaremos ahora por excepciones (comentaré las líneas que cambian y agrego a 
continuación las nuevas): <br />
<script src="https://gist.github.com/4393484.js"></script>
<p>Se podría decir que el "throw" es similar a "return algo", lo que hace es "lanzar la excepción" a un nivel más arriba, donde se invocó originalmente la rutina, para que tomen el 
control de la situación anómala y procedan en consecuencia. </p>
<p>Por lo tanto, si todo el código anterior queremos “atraparlo” en un "try" para tenerlo 
controlado en caso de fallas, deberíamos hacer lo siguiente:</p>
<script src="https://gist.github.com/4393493.js"></script>
<script src="https://gist.github.com/4393496.js"></script>
Beneficios de las Excepciones <br />
- Permiten separar el código de manejo de errores del código que debe cumplir con los 
requerimientos de funcionalidad de la aplicación <br />
- Permite un manejo homogéneo de los errores: evitará que tengamos distintas estructuras para 
contener los errores, como ser: en algunos casos una cascada de if, en otros un switch y tal vez en otros algún objetos de manejo de errores. <br /> 
- No solo transfiere el control del sistema de un lugar a otro, sino que también trasmite 
información sobre la situación anómala: como unidad todas las excepciones manejan objetos 
de tipo Excepción y como todo objeto, tendrá atributos y métodos relacionados con el manejo 
de errores. <br />
<hr />
<p>El diseño tradicional de “3 capas” con el mismo sentido de flechas desde la 
”presentación” pasando por “dominio” y terminando en “persistencia”, por más aceptado que 
esté, el diseño no cumple con todos los conceptos que vimos, por lo tanto, el verdadero 
diseño de 3 capas bien implementado debería ser como en el diagrama de la derecha 
(“persistencia apuntando a dominio”). </p>
<img src="uml44.jpg" alt=""> <br>
<hr />
<b>Anexo I: "Qué es lo nuevo en PHP5?" </b><br />
1.Modificadores de acceso "public/private/protected" <br />
Se incorpora el uso de modificadores de acceso "public / private / protected" para atributos y métodos.  <br />
Definir el "alcance o visibilidad" (scope) es importante para poder aplicar el "principio de ocultación", es decir, proteger al objeto del exterior y solo permitir acceso a los datos y 
comportamientos que nosotros especifiquemos. PHP4 carecía completamente de esta posibilidad 
y antes "todo era público". <br />
Aunque por defecto cualquier método que no diga nada al principio de su firma signifca que es "public", para unificar el criterio y claridad de la codificación se sugiere que todos 
los método públicos inicien siempre con el "modificador de acceso" correspondiente. <br />
<img src="uml45.jpg" alt=""> <br>
<b>2. El método reservado __construct() </b><br />
En PHP4 para definir un constructor había que escribir un método con el mismo nombre de la clase (al igual que lo hace Java) <br />
<img src="uml46.jpg" alt=""> <br>
PHP5 incorpora ahora un método exclusivo, a través del métod reservado __construct <br />
<img src="uml47.jpg" alt=""> <br>
<b>3. El método reservado __destructor() </b><br />
<p>De la misma forma que el constructor, se agrega un método reservado que permite agregar 
funcionalidad cuando el objeto se destruya (por ejemplo, desconectarnos de una base de datos en el momento que se haga un unset de la instancia).</p>
<img src="uml48.jpg" alt=""> <br>
<b>4. Interfaces</b><br />
<p>Se incorpora por primera vez la posibilidad de crear interfaces y poder agrupar clases "que hacen lo mismo" o "que tienen operaciones comunes". </p>
<img src="uml49.jpg" alt=""> <br>
<p>A diferencia de la herencia, se pueden implementar varias interfaces, por lo que podemos llegar a tener una clase que herede de una clase y que además implemente varias interfaces: 
</p>
<img src="uml50.jpg" alt=""> <br>
<b>5. El operador "instance of"  </b><br />
<p>Se deja de usar el operador de PHP4 is_a() y se agrega uno nuevo más especializado para objetos: "es instancia de": </p>
<pre style='color:#000000;background:#ffffff;'><span style='color:#5f5035; background:#ffffe8; '></span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#800000; background:#ffffe8; font-weight:bold; '>if</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#808030; background:#ffffe8; '>(</span><span style='color:#797997; background:#ffffe8; '>$obj</span><span style='color:#000000; background:#ffffe8; '> instance of Circle</span><span style='color:#808030; background:#ffffe8; '>)</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>print</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#0000e6; background:#ffffe8; '>'$obj is a Circle'</span><span style='color:#800080; background:#ffffe8; '>;</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#5f5035; background:#ffffe8; '></span>
</pre>
Aquí estamos preguntando si la instancia "obj" es de tipo "la clase Círculo".  <br />
<p>Aunque "tecnicamente exista y pueda usarse ", no se recomienda estar preguntando  a las instancias cual es su clase, ya que rompemos los diseños genéricos que pueden hacer uso del 
polimorfismo (estrategia base del DOO). </p>
<b>6. Operador "final" para los métodos </b><br />
<p>Final es otra herramienta que nos permite reforzar el diseño de nuestra clase. En este caso podemos definir qué métodos que otra clase vaya a heredar no pueden ser modificados a 
través de la "sobreescritura" de los mismos (los métodos deben usarse tal cual se reciben de 
su padre).  </p>
<img src="uml51.jpg" alt=""> <br>
<b>7. Operador "final" para la clase </b><br />
<pre style='color:#000000;background:#ffffff;'><span style='color:#5f5035; background:#ffffe8; '></span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#800000; background:#ffffe8; font-weight:bold; '>final</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>class</span><span style='color:#000000; background:#ffffe8; '> FinalClass </span>
<span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#800000; background:#ffffe8; font-weight:bold; '>class</span><span style='color:#000000; background:#ffffe8; '> BogusClass </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>extends</span><span style='color:#000000; background:#ffffe8; '> FinalClass  </span>
<span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#5f5035; background:#ffffe8; '></span>
</pre>
<p>En este caso el sistema dará un error grave porque se intentó heredar de una clase que está definida como "final". </p>
<b>8. Método reservado __clone para clonado de objetos</b><br />
<p>Desde que PHP5 empieza a trabajar por referencia y no por valor (como hacía por defecto PHP4), toda asignación con objetos representa una copia de la referencia a un mismo objeto, 
pero nunca se crea otro objeto duplicado. Si necesitáramos hacerlo (en casos muy 
especiales), podremos usar el comando clone. </p>
<img src="uml52.jpg" alt=""> <br>
<img src="uml53.jpg" alt=""> <br>
<p>En este ejemplo podemos ver cómo se usa el método __clone, en el cual agregaremos que si alguien quiere clonar nuestro objeto no tenga el valor de la clave del objeto original. </p>
<b>9. Atributos Constantes para las clases </b><br />
<p>Ahora se incorpora la posibilidad de incluir atributos constantes en las clases. Hay que tener en cuenta que como toda constante, estas son siempre públicas, y no podemos desde la 
clase esconderlas (su ámbito siempre será la clase). </p>
<img src="uml54.jpg" alt=""> <br>
<p>En este ejemplo podemos observar el uso de las constantes como forma de documentar y evitar los "números mágicos" (técnica de Refactoring), donde para conocer la lista de 
parámetros (sin importar saber de memoria sus valores) se lo podemos pedir a la misma clase 
consultando sus constantes (que son públicas y su propia descripción auto-documentan su 
uso). </p>
<p>Nota: las constantes se consideran "elementos de clase" (ver más adelante el apartado sobre "métodos estáticos"), por lo tanto dentro de la clase deberías usar self::CONSTANTE  
(igual puedes usar Clase::CONSTANTE).</p>
<b>10. Miembros estáticos o de clase (static) </b><br />
<p>Las clases pueden incluir elementos "estáticos" (también denominados "elementos de clase"), accesibles a través de la clase y no de la instancia.</p>
<p>El ejemplo más común es crear una clase Usuario que cada vez que se cree una instancia, 
la clase sepa cual es el último número de id y asignar dinámicamente un número más para el nuevo usuario. </p>
<img src="uml55.jpg" alt=""> <br>
<p>En este ejemplo podemos ver cómo a través del "atributo de clase" se mantiene la 
información entre instancias de la misma clase. Hay que tener en cuenta que este ejemplo no 
es del todo útil más allá de explicar cómo funciona, ya que cada vez que reiniciemos nuestra 
página, el contador empezará nuevamente de cero (para evitarlo habría que persistir esta 
información de alguna forma). </p>
<p>Otro uso común de los miembros estáticos es en el patrón Singleton, el cual está pensado para retornar siempre la misma instancia de un objeto: </p>
<pre style='color:#000000;background:#ffffff;'><span style='color:#5f5035; background:#ffffe8; '>&lt;?php</span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#800000; background:#ffffe8; font-weight:bold; '>class</span><span style='color:#000000; background:#ffffe8; '> Singleton  </span>
<span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>static</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>private</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#797997; background:#ffffe8; '>$_instance</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#808030; background:#ffffe8; '>=</span><span style='color:#000000; background:#ffffe8; '> NULL</span><span style='color:#800080; background:#ffffe8; '>;</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;</span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>private</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>function</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#400000; background:#ffffe8; '>__construct</span><span style='color:#808030; background:#ffffe8; '>(</span><span style='color:#808030; background:#ffffe8; '>)</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;</span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>static</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>public</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>function</span><span style='color:#000000; background:#ffffe8; '> getInstance</span><span style='color:#808030; background:#ffffe8; '>(</span><span style='color:#808030; background:#ffffe8; '>)</span><span style='color:#000000; background:#ffffe8; '>  </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>if</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#808030; background:#ffffe8; '>(</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>self</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#797997; background:#ffffe8; '>$_instance</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#808030; background:#ffffe8; '>=</span><span style='color:#808030; background:#ffffe8; '>=</span><span style='color:#000000; background:#ffffe8; '> NULL</span><span style='color:#808030; background:#ffffe8; '>)</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800080; background:#ffffe8; '>{</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>self</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#797997; background:#ffffe8; '>$_instance</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#808030; background:#ffffe8; '>=</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>new</span><span style='color:#000000; background:#ffffe8; '> Singleton</span><span style='color:#808030; background:#ffffe8; '>(</span><span style='color:#808030; background:#ffffe8; '>)</span><span style='color:#800080; background:#ffffe8; '>;</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>return</span><span style='color:#000000; background:#ffffe8; '> </span><span style='color:#800000; background:#ffffe8; font-weight:bold; '>self</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#800080; background:#ffffe8; '>:</span><span style='color:#797997; background:#ffffe8; '>$_instance</span><span style='color:#800080; background:#ffffe8; '>;</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#000000; background:#ffffe8; '>&#xa0;&#xa0;&#xa0;&#xa0;</span><span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '> </span>
<span style='color:#800080; background:#ffffe8; '>}</span><span style='color:#000000; background:#ffffe8; '></span>
<span style='color:#5f5035; background:#ffffe8; '></span>
</pre>
<b>11. Métodos estáticos o de clase (static) </b><br />
<p>De la misma forma que ahora se pueden crear atributos de clase, también se pueden crear métodos de clase o estáticos. En esencia la lógica es la misma, son métodos que se comparten 
entre elementos de la misma clase y no son "de instancia" (no requieren una instancia para 
poder usarse). </p>
<p>Por ejemplo, PHP tiene una función strtolower(), si quisiéramos ordenarlo en un entorno 100% Orientado a Objetos, podríamos decir que debería ser un método de una clase String, y 
deberíamos poder usarlo en cualquier ambiente, tanto bajo una instancia como sin ella. Si 
creamos un método común, solo lo podremos usar con una instancia: </p>
<img src="uml56.jpg" alt=""> <br>
<p>Bien podríamos cambiar el diseño y decir que no necesitamos crear constantemente una instancia que luego no se va a usar, por lo tanto cambiemos el método a "de clase".</p>
<img src="uml57.jpg" alt=""> <br>
De ahora en más podremos usarla de dos formas. <br />
Hay que tener en cuenta que si llamamos al método internamente, debemos cambiar el $this que se aplica a instancias por el método self que se aplica a elementos de clase. <br />
<img src="uml58.jpg" alt=""> <br>
<p>Otro ejemplo de uso muy tradicional es la típica clase Index, donde no necesariamente 
requiere que creemos una instancia, ya que solo la usaremos para iniciar la ejecución de un 
sistema, por lo que acceder a un método es suficiente. </p>
<b>12. Clases Abstractas  </b><br />
"abstract" es una forma de decir que una clase "no se puede instanciar". <br />
<b>13. Métodos abstractos </b><br />
<p>Un método abstracto obliga a una clase que hereda de la clase que lo contiene (al método abstracto) a definir el contenido de ese método. </p>
Una clase que tiene métodos abstractos debe definirse como clase abstracta. <br />
<p>De la misma forma que podemos decir que una clase abstracta puede ser usada como una 
clase "modelo" para que otra herede de ella, podemos decir que un método abstracto sirve de 
modelo para que una clase que herede tenga que implementar el método definido en la clase 
padre. </p>
<img src="uml59.jpg" alt=""> <br>
<b>14. Validación de Tipo a través de Clases ( type hints)</b><br />
<p>PHP desde sus orígenes es un lenguaje "dinámicamente tipado", lo que hace que cada 
variable defina su tipo según el valor que se le asigne, pero en sí no necesitamos como Java 
que es obligatorio definir el tipo antes de usarlo.</p>
<img src="uml60.jpg" alt=""> <br>
<p>Un detalle importante a tener en cuenta es que la validación es "mecánica", es decir, 
cuando recibe el objeto pregunta cual es su tipo (con qué clase se creó o cuales son sus 
padres) y luego comparará exactamente con la cadena de texto que agregamos a la izquierda 
(en este caso MyClass). </p>
De aquí se desprenden dos cosas: <br />
1. No es técnicamente necesario incluir la clase de filtro, por ejemplo, para usar el filtro MyClass no hace falta hacer un require_once de MyClass, ya que con el nombre solo ya le 
alcanza para hacer la comprobación. <br />
2. Cuando se hereda, una clase es del tipo base (su clase) y la de su padre, por lo tanto si 
soy un Usuario y además heredé de Persona, la validación puede ser filtro(Persona $persona) y ambas serán aceptadas, porque ambos objetos son "personas". <br />
<b>15.Soporte a invocaciones anidadas de objetos retornados </b><br />
En PHP4 estábamos obligados a hacer lo siguiente: 
<b>$dummy = $obj->method(); </b> <br />
<b>$dummy->method2(); </b> <br />
Ahora en PHP 5 podemos hacer las invocaciones en cadena de la siguiente forma: <br />
<b>$obj->method()->method2(); </b> <br />
Es una técnica muy utilizada y se le llama "Interfaces fluidas" (fluent interface), y para 
aplicarlas deberíamos, a cada método que queremos que se pueda anidar con la ejecución de 
otro, hacer que retorne la instancia actual con "this". De esta forma podemos anidarlos, ya 
que la salida de uno es la misma instancia que se va a aplicar en siguiente método. 
<img src="uml61.jpg" alt=""> <br>
<b>16. Iteradores </b><br />
<p>PHP5 permite ahora que las colecciones de una clase puedan ser iteradas a través de la 
misma clase con solo cumplir con una interface, así, con un simple foreach podremos recorrer 
los valores de un objeto: </p>
<img src="uml62.jpg" alt=""> <br>
<b>17. __autoload()</b><br />
<p>Es muy común que debamos incluir al principio de nuestra clase toda una serie de 
require_once de clases que necesitamos para trabajar. PHP5 ahora incorpora una función que 
permite definir un simple algoritmo de búsqueda de clases que se ejecutará siempre que 
nuestro fuente intente hacer un "new" de una clase (automáticamente la función recibirá por 
parámetros el nombre de la clase que intentamos instanciar, el resto lo definimos nosotros). </p>
<img src="uml63.jpg" alt=""> <br>

<script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "application/x-httpd-php",
        indentUnit: 4,
        indentWithTabs: true,
        enterMode: "keep",
        tabMode: "shift",
        readOnly: "true"
      });  
    </script>
</body>
</html>